import { Editor, RustAnalyzer } from "@wcrichto/rust-editor";
import _ from "lodash";
import React, { useEffect, useState } from "react";
import ReactDOM from "react-dom/client";

import spinnerUrl from "./assets/spinner.gif";
import "./index.scss";

interface EvalResult {
  success: boolean;
  stdout: string;
  stderr: string;
}
let evalRust = async (contents: string): Promise<EvalResult> => {
  var params = {
    channel: "stable",
    mode: "debug",
    code: contents,
    edition: "2021",
    crateType: contents.includes("fn main()") ? "bin" : "lib",
    backtrace: false,
    tests: false,
  };

  let response = await fetch("https://play.rust-lang.org/execute", {
    headers: {
      "Content-Type": "application/json",
    },
    method: "POST",
    mode: "cors",
    body: JSON.stringify(params),
  });

  return await response.json();
};

let RunnableEditor = ({
  ra,
  initialContents,
  onChange,
}: {
  ra?: RustAnalyzer;
  initialContents: string;
  onChange: (s: string) => void;
}) => {
  let [state] = useState(() => ({ contents: initialContents }));
  let [loading, setLoading] = useState(false);
  let [result, setResult] = useState<EvalResult | undefined>(undefined);
  let run = async () => {
    setLoading(true);
    try {
      let result = await evalRust(state.contents);
      setResult(result);
    } catch (e) {
      // todo
    }
    setLoading(false);
  };
  return (
    <div className="runnable-editor">
      <Editor
        contents={state.contents}
        onChange={(c: any) => {
          state.contents = c;
          onChange(c);
        }}
        ra={ra}
      />
      <div className="output">
        <div>
          <button onClick={run}>Run</button>
        </div>
        {loading ? (
          <img src={spinnerUrl} />
        ) : result ? (
          <div>
            <p>
              {result.success ? (
                <>Compilation has succeeded. The stdout of the process is:</>
              ) : (
                <>Compilation has failed. The stderr of the compiler is:</>
              )}
            </p>
            <pre className={result.success ? "stdout" : "stderr"}>
              {result.success
                ? result.stdout == ""
                  ? "(no stdout)"
                  : result.stdout
                : result.stderr}
            </pre>
          </div>
        ) : null}
      </div>
    </div>
  );
};

interface Answer {
  errorExplanation: string;
  messageInterpretation: string;
  safetyViolation: string;
  functionFix: string;
}

let Problem = ({
  snippet,
  next,
}: {
  snippet: string;
  next: (a: Answer) => void;
}) => {
  let [step, setStep] = useState(0);

  let [errorMessage, setErrorMessage] = useState<string | undefined>(undefined);
  useEffect(() => {
    evalRust(snippet).then(result => setErrorMessage(result.stderr));
  });

  let [ra, setRa] = useState<RustAnalyzer | undefined>(undefined);
  useEffect(() => {
    RustAnalyzer.load().then(setRa);
  }, []);

  let [answer] = useState<Answer>({
    errorExplanation: "",
    messageInterpretation: "",
    safetyViolation: "",
    functionFix: "",
  });

  let parts: ((finished: boolean) => React.ReactElement)[] = [
    finished => (
      <>
        <p>
          The following Rust function is rejected by the Rust compiler.{" "}
          <strong>
            In 1-2 sentences, explain why the compiler rejects this function.
          </strong>
        </p>
        <Editor
          disabled={true}
          contents={snippet}
          ra={!finished ? ra : undefined}
        />
        <p>
          <textarea
            disabled={finished}
            placeholder={"Write your answer here..."}
            onChange={e => {
              answer.errorExplanation = e.target.value;
            }}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>
          Below is the actual error message generated by the Rust compiler.{" "}
          <strong>
            Does the error message say what you expected the error would be?
          </strong>{" "}
        </p>
        <pre className="error">{errorMessage || "(loading...)"}</pre>
        <p>
          <textarea
            disabled={finished}
            placeholder={"Write your answer here..."}
            onChange={e => {
              answer.messageInterpretation = e.target.value;
            }}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>
          Assume that the compiler did NOT reject this function.{" "}
          <strong>
            Write a program that calls this function which would violate memory
            safety,
          </strong>{" "}
          for example by accessing deallocated memory. You may use pseudocode
          notation if you are unsure how to express something in correct Rust
          syntax.
        </p>
        <Editor
          contents={`fn main(){\n\n}`}
          disabled={finished}
          ra={!finished ? ra : undefined}
          onChange={(s: any) => {
            answer.safetyViolation = s;
          }}
        />
      </>
    ),
    _ => (
      <>
        <p>
          <strong>
            Fix this function to pass the compiler while preserving as much of
            its intent as possible.
          </strong>{" "}
          You can change any aspect of the function, including the type
          signature. You can click "Run" to get feedback from the compiler. You
          may use the{" "}
          <a href="https://doc.rust-lang.org/std/" target="_blank">
            standard library documentation
          </a>
          .
        </p>
        <RunnableEditor
          ra={ra}
          initialContents={snippet}
          onChange={s => {
            answer.functionFix = s;
          }}
        />
      </>
    ),
  ];

  return (
    <div className="problem">
      {parts
        .filter((_p, i) => i <= step)
        .map((part, i) => (
          <div key={i}>
            <h2>Part {i + 1}</h2>
            <div>{part(step != i)}</div>
            <button
              disabled={step != i}
              onClick={() => (step == 3 ? next(answer) : setStep(step + 1))}
            >
              Submit
            </button>
          </div>
        ))}
    </div>
  );
};

let Intro = ({ next }: { next: () => void }) => {
  return (
    <div className="container">
      <p>
        This page is a 30-minute experiment by Brown University researchers{" "}
        <a href="https://willcrichton.net/">Will Crichton</a> and{" "}
        <a href="https://cs.brown.edu/~sk/">Shriram Krishnamurthi</a>. You will
        be presented with a series of questions about ownership in Rust. Please
        answer to the best of your ability.
      </p>
      <p>
        <button style={{ marginRight: "20px" }} onClick={next}>
          I understand and want to participate
        </button>
        <button onClick={() => alert("Please close this tab.")}>
          I do not want to participate
        </button>
      </p>
    </div>
  );
};

let PROBLEMS = [
  `
// Makes a string to separate lines of text, 
// returning a default if the provided string is blank
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    &default
  } else {
    user_str
  }
}
  `,
  `
// Gets the string out of an option if it exists,
// returning a default otherwise
fn get_or_default(arg: &Option<String>) -> String {
  if arg.is_none() {
      return String::new();
  }
  let s = arg.unwrap();
  s.clone()
}
    `,
  `
// Removes all the zeros in-place from a vector of integers.
fn remove_zeros(v: &mut Vec<i32>) {
  for (i, t) in v.iter().enumerate().rev() {
    if *t == 0 {
      v.remove(i);
    }
  }
}
  `,
];

let App = () => {
  let [stage, setStage] = useState<"start" | "problems" | "end">("start");
  let [problem, setProblem] = useState(0);
  let [answers] = useState<any[]>([]);

  useEffect(() => {
    if (stage != "start" && stage != "end") {
      window.onbeforeunload = () =>
        "Are you sure you want to exit the experiment before finishing?";
      return () => {
        window.onbeforeunload = null;
      };
    }
  }, [stage]);

  useEffect(() => {
    if (stage == "end") {
      fetch("https://mindover.computer/ownership-inventory", {
        headers: {
          "Content-Type": "application/json",
        },
        method: "POST",
        mode: "cors",
        body: JSON.stringify(answers),
      });
    }
  }, [stage]);

  return (
    <>
      <div className="container">
        <h1>
          Ownership Inventory{" "}
          {stage == "problems" ? (
            <>
              - Problem {problem + 1}/{PROBLEMS.length}
            </>
          ) : null}
        </h1>
      </div>
      {stage === "start" ? (
        <Intro next={() => setStage("problems")} />
      ) : stage == "problems" ? (
        <Problem
          key={problem}
          snippet={PROBLEMS[problem].trim()}
          next={answer => {
            answers.push({
              question: PROBLEMS[problem],
              answer,
            });
            problem + 1 < PROBLEMS.length
              ? setProblem(problem + 1)
              : setStage("end");
          }}
        />
      ) : (
        <p>
          Thank you for your participation in the experiment! You may close this
          tab now.
        </p>
      )}
    </>
  );
};

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <App />
);
