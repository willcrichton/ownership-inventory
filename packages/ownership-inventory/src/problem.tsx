import { RustAnalyzer } from "@wcrichto/rust-editor";
import { motion, useAnimation } from "framer-motion";
import _ from "lodash";
import React, { useEffect, useMemo, useState } from "react";

import {
  EditorBlock,
  RunnableEditor,
  evalRust,
  scrollToBottom,
} from "./editor";

export type Timed<T> = T & { start: number; end: number };

export interface Answer {
  errorExplanation: string;
  messageInterpretation: string;
  safetyViolation: string;
  functionFix: string;
}

let MoreInfo: React.FC<React.PropsWithChildren> = ({ children }) => {
  let [open, setOpen] = useState(false);
  return (
    <span className="more-info">
      <span className="link" onClick={() => setOpen(!open)}>
        {open ? "Less context «" : "More context »"}
      </span>
      {open ? (
        <>
          <br />
          <br />
          {children}
        </>
      ) : null}
    </span>
  );
};

const RECOMMENDED_TIME = 15 * 60 * 1000;
const BEFORE_WARNING = 5 * 60 * 1000;

let Timer = ({ start }: { start: number }) => {
  let elapsed = new Date().getTime() - start;
  let beforeWarning = elapsed > RECOMMENDED_TIME - BEFORE_WARNING;
  let overTime = elapsed > RECOMMENDED_TIME;
  let spentMinutes = Math.floor(elapsed / (60 * 1000));

  let controls = useAnimation();
  useEffect(() => {
    if (!(beforeWarning || overTime)) return;

    controls.set({
      backgroundColor: "#ffdc00",
    });
    controls.start({
      backgroundColor: "#fff",
      transition: { duration: 2 },
    });
  }, [beforeWarning, overTime]);

  let [_n, render] = useState(0);
  useEffect(() => {
    let n = 0;
    let intvl = setInterval(() => render(n++), 1000);
    return () => clearInterval(intvl);
  }, []);

  let extraClass = overTime ? "finished" : beforeWarning ? "warning" : "";

  return (
    <motion.div className={"timer " + extraClass} animate={controls}>
      You have spent{" "}
      <span className={"time " + extraClass}>{spentMinutes}</span> minutes on
      this task. {overTime ? <>You should continue to the next task.</> : null}
    </motion.div>
  );
};

export let Problem = ({
  snippet,
  next,
  ra,
  onStep,
}: {
  snippet: string;
  ra?: RustAnalyzer;
  next: (a: Timed<Answer>) => void;
  onStep?: (step: number) => void;
}) => {
  let start = useMemo(() => new Date().getTime(), [snippet]);
  let [step, setStep] = useState(0);

  let [errorMessage, setErrorMessage] = useState<string | undefined>();
  useEffect(() => {
    evalRust(snippet).then(result => setErrorMessage(result.stderr));
  });

  useEffect(scrollToBottom, [step]);

  let [answer] = useState<Answer>({
    errorExplanation: "",
    messageInterpretation: "",
    safetyViolation: "",
    functionFix: "",
  });

  let parts: ((finished: boolean) => React.ReactElement)[] = [
    finished => (
      <>
        <p>The following Rust function is rejected by the Rust compiler.</p>
        <EditorBlock
          exactHeight={true}
          disabled={true}
          contents={snippet}
          ra={!finished ? ra : undefined}
        />
        <p>
          <strong>
            What error message would you expect from the compiler?
          </strong>{" "}
          <MoreInfo>
            You do not need to exactly reproduce the wording &mdash; the
            question is about whether you generally understand how Rust would
            justify rejecting this function. And please don't try to compile
            this program. We are testing your understanding, not Rust's!
          </MoreInfo>
        </p>
        <p>
          <textarea
            className="response"
            disabled={finished}
            placeholder={"Write your answer here..."}
            onChange={e => {
              answer.errorExplanation = e.target.value;
            }}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>Below is the actual error message generated by the Rust compiler.</p>
        <pre className="error">{errorMessage || "(loading...)"}</pre>
        <p>
          <strong>
            How well does the error message match your expectations?
          </strong>{" "}
          <MoreInfo>
            There is no correct answer &mdash; we just want your reaction to the
            error message. If you find the wording confusing, please say so!
          </MoreInfo>
        </p>
        <p>
          <textarea
            className="response"
            disabled={finished}
            placeholder={"Write your answer here..."}
            onChange={e => {
              answer.messageInterpretation = e.target.value;
            }}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>
          Assume that the compiler did NOT reject this function.{" "}
          <strong>
            What is a program that calls this function which would violate
            memory safety or cause a data race? Explain your reasoning in a
            comment.
          </strong>{" "}
          <MoreInfo>
            If no such program exists, then explain in a comment why the
            function is actually safe. If you are uncertain of a particular Rust
            syntax, you may use pseudocode notation.
          </MoreInfo>
        </p>
        <EditorBlock
          contents={`fn main() {\n\n}`}
          disabled={finished}
          ra={!finished ? ra : undefined}
          onChange={(s: any) => {
            answer.safetyViolation = s;
          }}
        />
      </>
    ),
    _ => (
      <>
        <p>
          <strong>
            How can this function be changed to pass the compiler while
            preserving as much of its intent as possible? Justify your decisions
            in a comment.
          </strong>{" "}
          You may use the{" "}
          <a
            href="https://doc.rust-lang.org/std/"
            target="_blank"
            rel="noreferrer"
          >
            standard library documentation
          </a>
          . You can click "Run" to get feedback from the compiler.{" "}
          <MoreInfo>
            There is no right answer &mdash; use your judgment to decide what
            changes best capture the function's intent. You can change any
            aspect of the function, including the type signature.
          </MoreInfo>
        </p>
        <RunnableEditor
          ra={ra}
          initialContents={snippet}
          onChange={s => {
            answer.functionFix = s;
          }}
        />
      </>
    ),
  ];

  return (
    <div className="problem">
      <Timer start={start} />
      <div className="parts">
        {parts
          .filter((_p, i) => i <= step)
          .map((part, i) => (
            <div className="part" key={i}>
              <h2>Part {i + 1}</h2>
              <div>{part(step != i)}</div>
              <button
                disabled={step != i}
                onClick={() => {
                  onStep && onStep(step + 1);
                  if (step == 3)
                    next({ ...answer, start, end: new Date().getTime() });
                  else setStep(step + 1);
                }}
              >
                Submit
              </button>
            </div>
          ))}
      </div>
    </div>
  );
};
