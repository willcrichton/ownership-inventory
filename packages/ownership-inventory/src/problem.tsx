import { motion, useAnimation } from "framer-motion";
import _ from "lodash";
import React, { useEffect, useMemo, useState } from "react";

import {
  EditorBlock,
  RunnableEditor,
  evalRust,
  scrollToBottom,
} from "./editor";

export type Timed<T> = T & { start: number; end: number };

export interface Answer {
  errorExplanation: string;
  messageInterpretation: string;
  safetyViolation: string;
  safetyViolationJustification: string;
  functionFix: string;
  functionFixJustification: string;
}

let MoreInfo: React.FC<React.PropsWithChildren> = ({ children }) => {
  let [open, setOpen] = useState(false);
  return (
    <span className="more-info">
      <span className="link" onClick={() => setOpen(!open)}>
        {open ? "Less context «" : "More context »"}
      </span>
      {open ? (
        <>
          <br />
          <br />
          {children}
        </>
      ) : null}
    </span>
  );
};

const RECOMMENDED_TIME = 15 * 60 * 1000;
const BEFORE_WARNING = 5 * 60 * 1000;

let Timer = ({ start }: { start: number }) => {
  let elapsed = new Date().getTime() - start;
  let beforeWarning = elapsed > RECOMMENDED_TIME - BEFORE_WARNING;
  let overTime = elapsed > RECOMMENDED_TIME;
  let spentMinutes = Math.floor(elapsed / (60 * 1000));

  let controls = useAnimation();
  useEffect(() => {
    if (!(beforeWarning || overTime)) return;

    controls.set({
      backgroundColor: "#ffdc00",
    });
    controls.start({
      backgroundColor: "#fff",
      transition: { duration: 2 },
    });
  }, [beforeWarning, overTime]);

  let [_n, render] = useState(0);
  useEffect(() => {
    let n = 0;
    let intvl = setInterval(() => render(n++), 1000);
    return () => clearInterval(intvl);
  }, []);

  let extraClass = overTime ? "finished" : beforeWarning ? "warning" : "";

  return (
    <motion.div className={"timer " + extraClass} animate={controls}>
      You have spent{" "}
      <span className={"time " + extraClass}>{spentMinutes}</span> minutes on
      this task. {overTime ? <>You should continue to the next task.</> : null}
    </motion.div>
  );
};

let ResponseArea = ({
  finished,
  onChange,
}: {
  finished: boolean;
  onChange: (text: string) => void;
}) => (
  <textarea
    className="response"
    disabled={finished}
    placeholder={"Write your answer here..."}
    onChange={e => {
      onChange(e.target.value);
    }}
  />
);

export let Problem = ({
  snippet,
  next,
  onStep,
}: {
  snippet: string;
  next: (a: Timed<Answer>) => void;
  onStep?: (step: number) => void;
}) => {
  let start = useMemo(() => new Date().getTime(), [snippet]);
  let [step, setStep] = useState(0);

  let [errorMessage, setErrorMessage] = useState<string | undefined>();
  useEffect(() => {
    evalRust(snippet).then(result => setErrorMessage(result.stderr));
  });

  useEffect(scrollToBottom, [step]);

  let [answer] = useState<Answer>({
    errorExplanation: "",
    messageInterpretation: "",
    safetyViolation: "",
    safetyViolationJustification: "",
    functionFix: "",
    functionFixJustification: "",
  });

  let parts: ((finished: boolean) => React.ReactElement)[] = [
    finished => (
      <>
        <p>The following Rust function is rejected by the Rust compiler.</p>
        <EditorBlock exactHeight={true} disabled={true} contents={snippet} />
        <p>
          <strong>
            What error message would you expect from the compiler?
          </strong>{" "}
          <MoreInfo>
            You do not need to exactly reproduce the wording &mdash; the
            question is about whether you generally understand how Rust would
            justify rejecting this function. And please don't try to compile
            this program. We are testing your understanding, not Rust's!
          </MoreInfo>
        </p>
        <p>
          <ResponseArea
            finished={finished}
            onChange={s => (answer.errorExplanation = s)}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>Below is the actual error message generated by the Rust compiler.</p>
        <pre className="error">{errorMessage || "(loading...)"}</pre>
        <p>
          <strong>
            How well does the error message match your expectations?
          </strong>{" "}
          <MoreInfo>
            There is no correct answer &mdash; we just want your reaction to the
            error message. If you find the wording confusing, please say so!
          </MoreInfo>
        </p>
        <p>
          <ResponseArea
            finished={finished}
            onChange={s => (answer.messageInterpretation = s)}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>
          Assume that the compiler did NOT reject this function.{" "}
          <strong>
            3A: What is a program that calls this function which would violate
            memory safety or cause a data race?
          </strong>{" "}
          <MoreInfo>
            If no such program exists, then leave this field blank and explain
            you reasoning below. If you are uncertain of a particular Rust
            syntax, you may use pseudocode notation.
          </MoreInfo>
        </p>
        <EditorBlock
          contents={`fn main() {\n\n}`}
          disabled={finished}
          onChange={(s: any) => {
            answer.safetyViolation = s;
          }}
        />
        <p>
          <strong>
            3B: In a few sentences, explain why you believe your program will
            violate memory safety or cause a data race, or why it is impossible
            to write such a program.
          </strong>
        </p>
        <ResponseArea
          finished={finished}
          onChange={s => (answer.safetyViolationJustification = s)}
        />
      </>
    ),
    finished => (
      <>
        <p>
          <strong>
            4A: How can this function be changed to pass the compiler while (1)
            preserving its intent and (2) reducing runtime performance?
          </strong>{" "}
          You may use the{" "}
          <a
            href="https://doc.rust-lang.org/std/"
            target="_blank"
            rel="noreferrer"
          >
            standard library documentation
          </a>
          . You can click "Run" to get feedback from the compiler.{" "}
          <MoreInfo>
            There is no right answer &mdash; use your judgment to decide what
            changes best capture the function's intent. You can change any
            aspect of the function, including the type signature.
          </MoreInfo>
        </p>
        <RunnableEditor
          initialContents={snippet}
          onChange={s => {
            answer.functionFix = s;
          }}
        />
        <p>
          <strong>
            4B: In a few sentences, explain why your fix satisfies the criteria
            above.
          </strong>
        </p>
        <ResponseArea
          finished={finished}
          onChange={s => (answer.functionFixJustification = s)}
        />
      </>
    ),
  ];

  return (
    <div className="problem">
      <Timer start={start} />
      <div className="parts">
        {parts
          .filter((_p, i) => i <= step)
          .map((part, i) => (
            <div className="part" key={i}>
              <h2>Part {i + 1}</h2>
              <div>{part(step != i)}</div>
              <button
                disabled={step != i}
                onClick={() => {
                  onStep && onStep(step + 1);
                  if (step == 3)
                    next({ ...answer, start, end: new Date().getTime() });
                  else setStep(step + 1);
                }}
              >
                Submit
              </button>
            </div>
          ))}
      </div>
    </div>
  );
};
