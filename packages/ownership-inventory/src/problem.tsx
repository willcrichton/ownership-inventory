import Tippy from "@tippyjs/react";
import { RustAnalyzer } from "@wcrichto/rust-editor";
import _ from "lodash";
import React, { useEffect, useState } from "react";
import "tippy.js/dist/tippy.css";

import {
  EditorBlock,
  RunnableEditor,
  evalRust,
  scrollToBottom,
} from "./editor";

export interface Answer {
  errorExplanation: string;
  messageInterpretation: string;
  safetyViolation: string;
  functionFix: string;
}

let MoreInfo: React.FC<React.PropsWithChildren> = ({ children }) => (
  // z-index has to be larger than Monaco and Intro.js
  <Tippy content={children} trigger={"click"} zIndex={100000001}>
    <span className="info-wrapper">
      <span className="info" />
    </span>
  </Tippy>
);

export let Problem = ({
  snippet,
  next,
  ra,
  onStep,
}: {
  snippet: string;
  ra?: RustAnalyzer;
  next: (a: Answer) => void;
  onStep?: (step: number) => void;
}) => {
  let [step, setStep] = useState(0);

  let [errorMessage, setErrorMessage] = useState<string | undefined>(undefined);
  useEffect(() => {
    evalRust(snippet).then(result => setErrorMessage(result.stderr));
  });

  useEffect(scrollToBottom, [step]);

  let [answer] = useState<Answer>({
    errorExplanation: "",
    messageInterpretation: "",
    safetyViolation: "",
    functionFix: "",
  });

  let parts: ((finished: boolean) => React.ReactElement)[] = [
    finished => (
      <>
        <p>The following Rust function is rejected by the Rust compiler.</p>
        <EditorBlock
          exactHeight={true}
          disabled={true}
          contents={snippet}
          ra={!finished ? ra : undefined}
        />
        <p>
          <strong>
            What error message would you expect from the compiler?
          </strong>{" "}
          <MoreInfo>
            You do not need to exactly reproduce the wording &mdash; the
            question is about whether you generally understand how Rust would
            justify rejecting this function. And please don't try to compile
            this program. We are testing your understanding, not Rust's!
          </MoreInfo>
        </p>
        <p>
          <textarea
            className="response"
            disabled={finished}
            placeholder={"Write your answer here..."}
            onChange={e => {
              answer.errorExplanation = e.target.value;
            }}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>Below is the actual error message generated by the Rust compiler.</p>
        <pre className="error">{errorMessage || "(loading...)"}</pre>
        <p>
          <strong>
            How well does the error message match your expectations?
          </strong>{" "}
          <MoreInfo>
            There is no correct answer &mdash; we just want your reaction to the
            error message. If you find the wording confusing, please say so!
          </MoreInfo>
        </p>
        <p>
          <textarea
            disabled={finished}
            placeholder={"Write your answer here..."}
            onChange={e => {
              answer.messageInterpretation = e.target.value;
            }}
          />
        </p>
      </>
    ),
    finished => (
      <>
        <p>
          Assume that the compiler did NOT reject this function.{" "}
          <strong>
            What is a program that calls this function which would violate
            memory safety or cause a data race?
          </strong>{" "}
          Write your answer below.{" "}
          <MoreInfo>
            If no such program exists, then explain in a comment why the
            function is actually safe. If you are uncertain of a particular Rust
            syntax, you may use pseudocode notation.
          </MoreInfo>
        </p>
        <EditorBlock
          contents={`fn main() {\n\n}`}
          disabled={finished}
          ra={!finished ? ra : undefined}
          onChange={(s: any) => {
            answer.safetyViolation = s;
          }}
        />
      </>
    ),
    _ => (
      <>
        <p>
          <strong>
            How can this function be changed to pass the compiler while
            preserving as much of its intent as possible?
          </strong>{" "}
          Write your answer below. You may use the{" "}
          <a
            href="https://doc.rust-lang.org/std/"
            target="_blank"
            rel="noreferrer"
          >
            standard library documentation
          </a>
          . You can click "Run" to get feedback from the compiler.{" "}
          <MoreInfo>
            There is no right answer &mdash; use your judgment to decide what
            changes best capture the function's intent. You can change any
            aspect of the function, including the type signature.
          </MoreInfo>
        </p>
        <RunnableEditor
          ra={ra}
          initialContents={snippet}
          onChange={s => {
            answer.functionFix = s;
          }}
        />
      </>
    ),
  ];

  return (
    <div className="problem">
      {parts
        .filter((_p, i) => i <= step)
        .map((part, i) => (
          <div className="part" key={i}>
            <h2>Part {i + 1}</h2>
            <div>{part(step != i)}</div>
            <button
              disabled={step != i}
              onClick={() => {
                onStep && onStep(step + 1);
                if (step == 3) next(answer);
                else setStep(step + 1);
              }}
            >
              Submit
            </button>
          </div>
        ))}
    </div>
  );
};
