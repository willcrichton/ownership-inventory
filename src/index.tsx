import _, { runInContext } from "lodash";
import { stringify } from "querystring";
import React, { useContext, useEffect, useRef, useState } from "react";
import ReactDOM from "react-dom/client";
import { Editor, RustAnalyzer } from "./editor/mod";

import "./index.scss";

let EditorContext = React.createContext({ content: "" });

let Evaluator = ({
  registerRunner,
  step,
}: {
  registerRunner: (f: () => void) => void;
  step: number;
}) => {
  let ctx = useContext(EditorContext);
  let [output, setOutput] = useState<string | null>(null);

  let run = async () => {
    var params = {
      version: "stable",
      optimize: "0",
      code: ctx.content,
      edition: "2021",
    };

    let response = await fetch("https://play.rust-lang.org/evaluate.json", {
      headers: {
        "Content-Type": "application/json",
      },
      method: "POST",
      mode: "cors",
      body: JSON.stringify(params),
    });
    let data = await response.json();
    setOutput(data.result);
  };

  useEffect(() => {
    registerRunner(run);
  }, []);

  return (
    <div>
      {step == 2 ? <button onClick={run}>Run</button> : null}
      {output ? <pre>{output}</pre> : null}
    </div>
  );
};

let Problem = ({ next }: { next: () => void }) => {
  let snippet = `
// Makes a string to separate lines of text, 
// returning a default if the provided string is blank
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    &default
  } else {
    user_str
  }
}

/* Part 1

*/

// Part 2
fn main() {

}
`;

  let [state] = useState<{ content: string; runner?: () => void }>(() => ({
    content: snippet,
  }));
  let [step, setStep] = useState(0);

  let [ra, setRa] = useState<RustAnalyzer | undefined>(undefined);
  useEffect(() => {
    RustAnalyzer.load().then(setRa);
  }, []);

  return (
    <EditorContext.Provider value={state}>
      <div>
        <div>
          <p>
            Below is a Rust function that is rejected by the compiler. For Part
            1, determine why the compiler rejects this function. Write your
            answer in the blank under the comment <code>/* Part 1</code>.
            Remember to talk aloud as you think.
          </p>
          <p>
            Once you are confident in your answer, or if you absolutely cannot
            figure it out, then click here:{" "}
            <button
              disabled={step > 0}
              onClick={() => {
                state.runner!();
                setStep(step + 1);
              }}
            >
              Next Part
            </button>
          </p>
          {step > 0 ? (
            <>
              <p>
                Now, read the error generated by the compiler. Does the error
                message say what you expected the error would be? Or if you
                couldn't figure it out, does the error message show you the
                error? Say your answer aloud.
              </p>
              <p>
                For Part 2, imagine that the compiler did NOT reject this
                function. Write a program that calls this function which would
                violate memory safety, for example by accessing deallocated
                memory. Write your answer inside <code>fn main()</code>.
              </p>
              <p>
                Once you are confident in your answer, or if you absolutely
                cannot figure it out, then click here:{" "}
                <button
                  disabled={step > 1}
                  onClick={() => {
                    setStep(step + 1);
                  }}
                >
                  Next Part
                </button>
              </p>
              {step > 1 ? (
                <>
                  <p>
                    For Part 3, your goal is to fix this program such that it
                    passes the compiler while preserving the intention of the
                    program. At any point, you can click the "Run" button below
                    to get feedback from the compiler.
                  </p>
                  <p>
                    Once you are confident in your answer, or if you absolutely
                    cannot figure it out, then click here:{" "}
                    <button onClick={next}>Finish Question</button>
                  </p>
                </>
              ) : null}
            </>
          ) : null}
        </div>
        <Editor
          contents={snippet}
          ra={ra}
          onChange={(s) => (state.content = s)}
        />
        <Evaluator
          step={step}
          registerRunner={(runner) => {
            state.runner = runner;
          }}
        />
      </div>
    </EditorContext.Provider>
  );
};

let Intro = ({ next }: { next: () => void }) => {
  return (
    <div>
      <p>
        This page is a 15-minute experiment by Brown University researchers{" "}
        <a href="https://willcrichton.net/">Will Crichton</a> and{" "}
        <a href="https://cs.brown.edu/~sk/">Shriram Krishnamurthi</a>. You will
        be presented with a series of open-ended questions about ownership in
        Rust.
      </p>
      <p>
        To help us understand your problem-solving process, this webpage will
        record your screen and microphone. You will talk aloud as you solve each
        problem. At the end, the recordings will be securely saved to our
        server.
      </p>
      <p>
        <button onClick={next}>I understand and want to participate</button>
        <button onClick={() => alert("Please close this tab.")}>
          I do not want to participate
        </button>
      </p>
    </div>
  );
};

let VideoPreview = ({ stream }: { stream: MediaStream }) => {
  let ref = useRef<HTMLVideoElement>(null);
  useEffect(() => {
    ref.current!.srcObject = stream;
  }, []);
  return <video width={300} height={300} autoPlay ref={ref} />;
};

let AudioPreview = ({ stream }: { stream: MediaStream }) => {
  let visualizer = useRef<HTMLDivElement>(null);
  useEffect(() => {
    (async () => {
      let ctx = new AudioContext();
      let src = ctx.createMediaStreamSource(stream);
      await ctx.audioWorklet.addModule("vumeter-worklet.js");
      let node = new AudioWorkletNode(ctx, "vumeter");
      src.connect(node);

      let volumes: number[] = [];
      node.port.onmessage = (event) => {
        volumes.push(event.data.volume);
        if (volumes.length > 10) volumes.shift();
      };

      let stop = false;
      let draw = () => {
        if (stop || !visualizer.current) return;
        requestAnimationFrame(draw);
        let avg = _.mean(volumes);
        let width = Math.min(3000 * avg, 500);
        visualizer.current.style.width = `${width}px`;
      };
      draw();
      return () => {
        stop = true;
      };
    })();
  }, []);
  return (
    <div>
      <div className="audio-visualizer">
        <div className="bar" ref={visualizer} />
      </div>
    </div>
  );
};

let RecordingSetup = ({
  next,
  registerRecorder,
}: {
  next: () => void;
  registerRecorder: (recorder: MediaRecorder) => void;
}) => {
  let [videoStream, setVideoStream] = useState<MediaStream | null>(null);
  let [audioStream, setAudioStream] = useState<MediaStream | null>(null);

  let initVideo = async () => {
    try {
      setVideoStream(
        await navigator.mediaDevices.getDisplayMedia({
          video: true,
          preferCurrentTab: true,
        } as any)
      );
    } catch (err) {
      console.error(err);
      return;
    }
  };

  let initAudio = async () => {
    try {
      setAudioStream(
        await navigator.mediaDevices.getUserMedia({
          audio: {
            noiseSuppression: true,
            echoCancellation: true,
          },
        })
      );
    } catch (err) {
      console.error(err);
      return;
    }
  };

  let finish = () => {
    if (!videoStream || !audioStream) throw new Error("Unreachable");

    let audioTrack = audioStream.getTracks()[0];
    videoStream.addTrack(audioTrack);
    audioStream.removeTrack(audioTrack);

    videoStream.getVideoTracks()[0].addEventListener("ended", () => {
      // TODO: handle the case where user cancels recording
    });

    let recorder = new MediaRecorder(videoStream!);
    recorder.start();
    registerRecorder(recorder);
    next();
  };

  return (
    <div>
      <p>
        First, we need to setup the recording. Click the button below to enable
        screen recording:
      </p>
      <p>
        <button onClick={initVideo}>Enable screen recording</button>
      </p>
      {videoStream ? (
        <>
          <p>
            If that worked correctly, you should see the current web page in the
            streaming video below. If you see a different page, please click the
            button above again.
          </p>
          <VideoPreview stream={videoStream!} />
          <p>Next, click the button below to enable mic recording:</p>
          <p>
            <button onClick={initAudio}>Enable mic recording</button>
          </p>
          {audioStream ? (
            <>
              <p>
                Try speaking into your microphone. If that worked correctly,
                then you should see a green bar going up as you talk.
              </p>
              <AudioPreview stream={audioStream!} />
              <p>
                If both the video and the audio are working, then click here to
                continue:
              </p>
              <button onClick={finish}>Continue</button>
            </>
          ) : null}
        </>
      ) : null}
    </div>
  );
};

let Outro = ({ recorder }: { recorder: MediaRecorder }) => {
  useEffect(() => {
    recorder.addEventListener("dataavailable", (e) => {
      if (e.data.size > 0) {
        let mime = e.data.type.split(";")[0];
        console.log("Mime type", mime, e.data.type);
        let exts: { [k: string]: string } = {
          "video/x-matroska": "mkv",
          "video/mp4": "mp4",
        };
        let ext = exts[mime] || "unk";
        let url = URL.createObjectURL(e.data);
        let a = document.createElement("a");
        a.href = url;
        a.download = `recording.${ext}`;
        a.click();
        URL.revokeObjectURL(url);
      }
    });
    recorder.stop();
    recorder.stream.getTracks().forEach((track) => track.stop());
  });
  return (
    <div>
      <p>
        Thank you for your participation in the experiment! We have stopped
        recording your screen and audio.
      </p>
      <p className="warning">TODO: this will send the data to the server</p>
    </div>
  );
};

let App = () => {
  let [stage, setStage] = useState("start");
  let [recorder, setRecorder] = useState<MediaRecorder | null>(null);
  return (
    <div className="container">
      <h1>Ownership Inventory</h1>
      {stage === "start" ? (
        <Intro next={() => setStage("setup")} />
      ) : stage === "setup" ? (
        <RecordingSetup
          next={() => setStage("problem")}
          registerRecorder={setRecorder}
        />
      ) : stage == "problem" ? (
        <Problem next={() => setStage("end")} />
      ) : (
        <Outro recorder={recorder!} />
      )}
    </div>
  );
};

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <App />
);
