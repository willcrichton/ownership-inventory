import _ from "lodash";
import spinnerUrl from "./assets/spinner.gif";
import React, { useEffect, useState } from "react";
import ReactDOM from "react-dom/client";
import { observer, useLocalObservable } from "mobx-react";
import { Editor, RustAnalyzer } from "./editor/mod";
import { RecordingSetup, Outro } from "./recording";
import "./index.scss";

interface ProblemState {
  step: number;
  contents: string;
  runner?: () => void;
}

let Evaluator = observer(({ state }: { state: ProblemState }) => {
  let [loading, setLoading] = useState<boolean>(false);
  let [output, setOutput] = useState<{ result: string; error?: string } | null>(
    null
  );

  let run = async () => {
    var params = {
      version: "stable",
      optimize: "0",
      code: state.contents,
      edition: "2021",
    };

    setLoading(true);
    let response;
    try {
      response = await fetch("https://play.rust-lang.org/evaluate.json", {
        headers: {
          "Content-Type": "application/json",
        },
        method: "POST",
        mode: "cors",
        body: JSON.stringify(params),
      });
    } catch (e) {
      console.error("Rust playground failed to respond!", e);
      setLoading(false);
      return;
    }

    let data = await response.json();
    setLoading(false);
    setOutput(data);
  };

  useEffect(() => {
    state.runner = run;
  }, []);

  return (
    <div className="evaluator">
      {state.step == 3 ? (
        <div>
          <button onClick={run}>Run</button>
        </div>
      ) : null}
      {loading ? (
        <div>
          <img src={spinnerUrl} />
        </div>
      ) : output ? (
        <div>
          <div>
            {output.error ? (
              <>Compilation failed with the following error:</>
            ) : (
              <>Compilation succeeded, and the stdout of the program was:</>
            )}
          </div>
          <pre className={output.error ? "error" : "success"}>
            {output.result}
          </pre>
        </div>
      ) : null}
    </div>
  );
});

let Instructions = observer(
  ({ next, state }: { state: ProblemState; next: () => void }) => {
    let shouldShow = (n: number) => ({
      style: { display: state.step >= n ? "block" : "none" },
    });
    return (
      <div className="instructions">
        <div>
          <h2>Part 1</h2>
          <p>
            To the right is a Rust function that is rejected by the compiler.{" "}
            <strong>Determine why the compiler rejects this function.</strong>{" "}
            Write your answer in the blank under the comment{" "}
            <code>/* Part 1</code>. Remember to talk aloud as you think.
          </p>
          <p>
            Once you are confident in your answer, or if you absolutely cannot
            figure it out, then click here:{" "}
            <button
              disabled={state.step > 0}
              onClick={() => {
                state.runner!();
                state.step += 1;
              }}
            >
              Next Part
            </button>
          </p>
        </div>
        <div {...shouldShow(1)}>
          <h2>Part 2</h2>
          <p>
            Now, read the error generated by the compiler.{" "}
            <strong>
              Does the error message say what you expected the error would be?
            </strong>{" "}
            Or if you couldn't figure it out, does the error message show you
            the error? Write your answer under <code>/* Part 2</code>, and click
            here when you are done:{" "}
            <button
              disabled={state.step > 1}
              onClick={() => {
                state.step += 1;
              }}
            >
              Next Part
            </button>
          </p>
        </div>
        <div {...shouldShow(2)}>
          <h2>Part 3</h2>
          <p>
            Imagine that the compiler did NOT reject this function.{" "}
            <strong>
              Write a program that calls this function which would violate
              memory safety,
            </strong>{" "}
            for example by accessing deallocated memory. Write your answer
            inside <code>fn main()</code>.
          </p>
          <p>
            Once you are confident in your answer, or if you absolutely cannot
            figure it out, then click here:{" "}
            <button
              disabled={state.step > 2}
              onClick={() => {
                state.step += 1;
              }}
            >
              Next Part
            </button>
          </p>
        </div>
        <div {...shouldShow(3)}>
          <h2>Part 4</h2>
          <p>
            Your final task is to fix this function to pass the compiler while
            preserving its intent. Write your answer under <code>Part 4</code>.
            You can change any aspect of the function, including the type
            signature. Additionally, you can click "Run" to get feedback from
            the compiler.
          </p>
          <p>
            Once you are confident in your answer, or if you absolutely cannot
            figure it out, then click here:{" "}
            <button onClick={next}>Finish Question</button>
          </p>
        </div>
      </div>
    );
  }
);

let Scratchpad = ({ state }: { state: ProblemState }) => {
  let [ra, setRa] = useState<RustAnalyzer | undefined>(undefined);
  useEffect(() => {
    RustAnalyzer.load().then(setRa);
  }, []);

  return (
    <div className="scratchpad">
      <Editor
        contents={state.contents}
        ra={ra}
        onChange={(s) => (state.contents = s)}
      />
      <Evaluator state={state} />
    </div>
  );
};

let Problem = ({ next }: { next: () => void }) => {
  let snippet = `
// Makes a string to separate lines of text, 
// returning a default if the provided string is blank
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    &default
  } else {
    user_str
  }
}

/* Part 1

*/

/* Part 2

*/

// Part 3
fn main() {

}

// Part 4
fn make_separator_fixed() -> () {

}
  `;
  let state = useLocalObservable<ProblemState>(() => ({
    step: 0,
    contents: snippet,
  }));

  return (
    <div className="problem">
      <Instructions next={next} state={state} />
      <Scratchpad state={state} />
    </div>
  );
};

let Intro = ({ next }: { next: () => void }) => {
  return (
    <div className="container">
      <p>
        This page is a 15-minute experiment by Brown University researchers{" "}
        <a href="https://willcrichton.net/">Will Crichton</a> and{" "}
        <a href="https://cs.brown.edu/~sk/">Shriram Krishnamurthi</a>. You will
        be presented with a series of questions about ownership in Rust.
      </p>
      <p>
        To help us understand your problem-solving process, this webpage will
        record your screen and microphone. You will talk aloud as you solve each
        problem. At the end, the recordings will be securely saved to our
        server.
      </p>
      <p>
        <button style={{ marginRight: "20px" }} onClick={next}>
          I understand and want to participate
        </button>
        <button onClick={() => alert("Please close this tab.")}>
          I do not want to participate
        </button>
      </p>
    </div>
  );
};

let App = () => {
  let [stage, setStage] = useState("start");
  let [recorder, setRecorder] = useState<MediaRecorder | null>(null);

  return (
    <>
      <div className="container">
        <h1>Ownership Inventory</h1>
      </div>
      {stage === "start" ? (
        <Intro next={() => setStage("setup")} />
      ) : stage === "setup" ? (
        <RecordingSetup
          next={() => setStage("problem")}
          registerRecorder={setRecorder}
        />
      ) : stage == "problem" ? (
        <Problem next={() => setStage("end")} />
      ) : (
        <Outro recorder={recorder!} />
      )}
    </>
  );
};

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <App />
);
